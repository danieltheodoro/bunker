module bunker;

# --- Symbol Table Definitions ---

struct Header {
    type: string;
}

struct NamedNode {
    type: string;
    name: string;
}

struct Symbol {
    name: string;
    type: string;
    isDefined: bool;
}

struct Scope {
    symbols: void*; # ASTList* of Symbol*
    parent: void*;  # Scope* (nullable)
}

Entity SymbolTable:
    has current: void*; # Scope*

    has static method new -> SymbolTable:
        st <- SymbolTable: alloc;
        # Root scope
        root <- Scope: alloc;
        root.symbols <- ASTList: new: nil, nil;
        root.parent <- nil;
        
        st.current <- root;
        return st;
    end method.

    has method enterScope -> void:
        newScope <- Scope: alloc;
        newScope.symbols <- ASTList: new: nil, nil;
        newScope.parent <- self.current;
        self.current <- newScope;
    end method.

    has method exitScope -> void:
        if:
        condition:
            return self.current == nil;
        end condition.
        then:
            return;
        end then.
        end if.
        
        # Cast to Scope to access parent
        scope: Scope <- self.current;
        self.current <- scope.parent;
    end method.

    has method define: name: string, type: string -> void:
        # Create symbol
        sym <- Symbol: alloc;
        sym.name <- name;
        sym.type <- type;
        sym.isDefined <- true;
        
        # Add to current scope's list
        scope: Scope <- self.current;
        list: ASTList <- scope.symbols;
        
        node <- ASTNode: new: sym, nil;
        
        if:
        condition:
            return list.head == nil;
        end condition.
        then:
             list.head <- node;
             list.tail <- node;
        end then.
        else:
             tail: ASTNode <- list.tail;
             tail.next <- node;
             list.tail <- node;
        end else.
        end if.
    end method.

    has method resolve: name: string -> string:
        curr: Scope <- self.current;
        print: "DEBUG: Resolving symbol: " + name;
        loop:
             if:
             condition:
                 return curr == nil;
             end condition.
             then:
                 break;
             end then.
             end if.
             
             # Search in current scope
             list: ASTList <- curr.symbols;
             node: ASTNode <- list.head;
             
             loop:
                 if:
                 condition:
                     return node == nil;
                 end condition.
                 then:
                     break;
                 end then.
                 end if.
                 if:
                 condition:
                     return node.value == nil;
                 end condition.
                 then:
                      node <- node.next;
                      continue;
                 end then.
                 end if.
                 
                 sym: Symbol <- node.value;
                 if:
                 condition:
                     return sym.name == name;
                 end condition.
                 then:
                      # print: "DEBUG: Found " + name + " as " + sym.type;
                      return sym.type;
                 end then.
                 end if.
                 
                 node <- node.next;
             end loop.
             
             # Move to parent
             curr <- curr.parent;
        end loop.
        
        print: "DEBUG: Resolution FAILED for: " + name;
        return "error";
    end method.
end Entity.

Entity TypeChecker:
    has parser: void*; # Parser*
    has symbols: void*; # SymbolTable*
    has source: string; # Source code for error reporting
    has hadError: bool;
    has globalTypes: void*; # ASTList* of Entity/StructDecl
    has currentEntity: string;
    has currentMode: string; # "static" or "instance"
    
    has static method new: p: void*, src: string -> TypeChecker:
        tc <- TypeChecker: alloc;
        tc.parser <- p;
        tc.source <- src;
        st <- SymbolTable: new;
        tc.symbols <- st;
        tc.hadError <- false;
        tc.globalTypes <- ASTList: new: nil, nil;
        tc.currentEntity <- "";
        # Register Built-ins
        st: define: "print", "method";
        st: define: "Memory", "entity";
        st: define: "FileSystem", "entity";
        st: define: "File", "entity";
        st: define: "int", "type";
        st: define: "string", "type";
        st: define: "bool", "type";
        st: define: "void", "type";
        return tc;
    end method.

    has method reportError: msg: string, tok: Token -> void:
        print: "TYPE ERROR: " + msg;
        if:
        condition:
            return tok != nil;
        end condition.
        then:
             print: "  at line " + tok.line + ", col " + tok.column + ": " + tok.value;
        end then.
        end if.
        ErrorReporter: report: msg, tok, self.source;
        self.hadError <- true;
    end method.
    
    has method checkProgram: prog: void* -> void:
         print: "Type Checking Program...";
         
         # Cast to Program (conceptually)
         # In C transpilation, void* is fine. We access fields by casting or assuming layout;
         # But in Bunker self-host, we need to know the structure to access fields if it's a struct;
         # Actually, accessing fields on void* directly isn't supported by my transpiler unless cast;
         
         # Wait, Program is a struct? Let's check definition;
         # struct Program { module: void*; imports: void*; stmts: void*; }
         
         p: Program <- prog;
         
         # 1. Check Module
         if:
         condition:
             return p.module != nil;
         end condition.
         then:
             self: checkModule: p.module;
         end then.
         end if.
         
         # 2. Check Imports (TODO)
         
         # 3. Check Statements
         list: ASTList <- p.stmts;
         if:
         condition:
             return list == nil;
         end condition.
         then:
             return;
         end then.
         end if.
         
         node: ASTNode <- list.head;
         loop:
             if:
             condition:
                 return node == nil;
             end condition.
             then:
                 break;
             end then.
             end if.
             
             stmt: void* <- node.value;
             self: checkStatement: stmt;
             
             node <- node.next;
         end loop.
         
         print: "Type Checking Complete.";
    end method.

    has method checkModule: mod: void* -> void:
        # TODO: Register module name?
        return;
    end method.

    has method checkStatement: stmt: void* -> void:
        if:
        condition:
            return stmt == nil;
        end condition.
        then:
            return;
        end then.
        end if.
        
        # Dispatch based on type field (all AST nodes have 'type' string first)
        # We need a generic way to check type;
        # Impl: Cast to generic struct with type field? Or just access .type if transpiler supports it on void* (it likely doesn't);
        # Workaround: Cast to Token? No;
        # We need a 'AnyNode' struct or similar?
        # Actually, in Bunker `void*` field access is not allowed. We must cast;
        # But we don't know the type yet!
        # Solution: All AST nodes should start with `type: string`;
        # We can cast to a dummy struct `Header { type: string }` to read the type;
        
        header: Header <- stmt; 
        type <- header.type;
        
        # Declarations
        if:
        condition:
            return type == "VariableDecl";
        end condition.
        then:
            self: checkVarDecl: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "MethodDecl";
        end condition.
        then:
            self: checkMethodDecl: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "StructDecl";
        end condition.
        then:
            self: checkStructDecl: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "EntityDecl";
        end condition.
        then:
             self: checkEntityDecl: stmt; return;
        end then.
        end if.
        
        # Statements
        if:
        condition:
            return type == "Block";
        end condition.
        then:
            self: checkBlock: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "IfStmt";
        end condition.
        then:
            self: checkIf: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "WhileStmt";
        end condition.
        then:
            self: checkWhile: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "LoopStmt";
        end condition.
        then:
            self: checkLoop: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "ReturnStmt";
        end condition.
        then:
            self: checkReturn: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "ExprStmt";
        end condition.
        then:
            self: checkExprStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "ScopedStmt";
        end condition.
        then:
            self: checkScopedStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "LetStmt";
        end condition.
        then:
            self: checkVarDecl: stmt; return;
        end then.
        end if.
        
        # print: "Unknown statement type: " + type;
    end method.

    has method checkScopedStmt: stmt: void* -> void:
        s: ScopedStmt <- stmt;
        self: checkBlock: s.body;
    end method.

    has method checkBlock: stmt: void* -> void:
        # Cast to Block
        # struct Block { type: string; stmts: void*; }
        # note: selfhost uses void* for list;
        
        blk: Block <- stmt;
        st: SymbolTable <- self.symbols;
        
        st: enterScope;
        
        list: ASTList <- blk.stmts;
        if:
        condition:
            return list != nil;
        end condition.
        then:
             node: ASTNode <- list.head;
             loop:
                 if:
                 condition:
                     return node == nil;
                 end condition.
                 then:
                     break;
                 end then.
                 end if.
                 self: checkStatement: node.value;
                 node <- node.next;
             end loop.
        end then.
        end if.
        
        st: exitScope;
    end method.

    has method checkExpression: expr: void* -> string:
        if:
        condition:
            return expr == nil;
        end condition.
        then:
            return "void";
        end then.
        end if.
        
        header: Header <- expr;
        type <- header.type;
        
        if:
        condition:
            return type == "LiteralExpr";
        end condition.
        then:
            return self: checkLiteral: expr;
        end then.
        end if.
        if:
        condition:
            return type == "VariableExpr";
        end condition.
        then:
            return self: checkVariable: expr;
        end then.
        end if.
        if:
        condition:
            return type == "AssignExpr";
        end condition.
        then:
            return self: checkAssign: expr;
        end then.
        end if.
        if:
        condition:
            return type == "BinaryExpr";
        end condition.
        then:
            return self: checkBinary: expr;
        end then.
        end if.
        if:
        condition:
            return type == "UnaryExpr";
        end condition.
        then:
            return self: checkUnary: expr;
        end then.
        end if.
        if:
        condition:
            return type == "MethodCall";
        end condition.
        then:
            return self: checkCall: expr;
        end then.
        end if.
        if:
        condition:
            return type == "LetStmt";
        end condition.
        then:
            self: checkVarDecl: expr; return "void";
        end then.
        end if.
        if:
        condition:
            return type == "Block";
        end condition.
        then:
             return self: checkBlockCondition: expr;
        end then.
        end if.
        if:
        condition:
            return type == "ArrayAccess";
        end condition.
        then:
            return self: checkArrayAccess: expr;
        end then.
        end if.
        if:
        condition:
            return type == "GetExpr";
        end condition.
        then:
            return self: checkGet: expr;
        end then.
        end if.
        
        return "error";
    end method.

    has method checkBlockCondition: stmt: void* -> string:
        blk: Block <- stmt;
        st: SymbolTable <- self.symbols;
        st: enterScope;
        
        let resType: string <- "void";
        list: ASTList <- blk.stmts;
        if:
        condition:
            return list != nil;
        end condition.
        then:
             node: ASTNode <- list.head;
             loop:
                 if:
                 condition:
                     return node == nil;
                 end condition.
                 then:
                     break;
                 end then.
                 end if.
                 
                 header: Header <- node.value;
                 if:
                 condition:
                     return header.type == "ReturnStmt";
                 end condition.
                 then:
                      ret: ReturnStmt <- node.value;
                      if:
                      condition:
                          return ret.value != nil;
                      end condition.
                      then:
                           resType <- self: checkExpression: ret.value;
                      end then.
                      end if.
                      # In condition blocks, return terminates and provides the value
                      break;
                 end then.
                 end if.

                 self: checkStatement: node.value;
                 node <- node.next;
             end loop.
        end then.
        end if.
        
        st: exitScope;
        return resType;
    end method.
    
    has method checkLiteral: expr: void* -> string:
        lit: LiteralExpr <- expr;
        return lit.literalType;
    end method.
    
    has method checkVariable: expr: void* -> string:
        var: VariableExpr <- Casts: toVariableExpr: expr;
        tk <- var.name;
        
        # Handle self
        if:
        condition:
            return tk.value == "self";
        end condition.
        then:
             if:
             condition:
                 return self.currentEntity == "";
             end condition.
             then:
                  self: reportError: "'self' used outside of an entity method", tk;
                  return "error";
             end then.
             end if.
             return self.currentEntity;
        end then.
        end if.

        st: SymbolTable <- self.symbols;
        print: "DEBUG: Resolving variable: " + tk.value;
        type: string <- st: resolve: tk.value;
        print: "DEBUG: Resolved " + tk.value + " to: " + type;
        
        if:
        condition:
            return type == "error";
        end condition.
        then:
             # Check if it's a global entity/struct name
             typeDecl: void* <- self: findType: tk.value;
             if:
             condition:
                 return typeDecl != nil;
             end condition.
             then:
                  return tk.value; # Return actual name (e.g. "Person")
             end then.
             end if.

             self: reportError: "Undefined variable '" + var.name.value + "'", var.name;
             return "error";
        end then.
        end if.
        
        # If it resolved to "entity" or "struct", return the name instead if we can find it
        if:
        condition:
            return type == "entity" or type == "struct";
        end condition.
        then:
             return tk.value;
        end then.
        end if.

        return type;
    end method.

    has method checkGet: expr: void* -> string:
        getExpr: GetExpr <- expr;
        objType <- self: checkExpression: getExpr.object;
        if:
        condition:
            return objType == "error";
        end condition.
        then:
            return "error";
        end then.
        end if.
        
        let memberName: string <- getExpr.nameTok.value;
        let retType: string <- self: findMember: objType, memberName;
        
        if:
        condition:
            return retType == "error";
        end condition.
        then:
             self: reportError: "Undefined member '" + memberName + "' on type " + objType, getExpr.nameTok;
             return "error";
        end then.
        end if.
        
        return retType;
    end method.
    
    has method checkAssign: expr: void* -> string:
        assign: AssignExpr <- expr;
        
        valueType <- self: checkExpression: assign.value;
        
        st: SymbolTable <- self.symbols;
        header: Header <- assign.target;
        
        if:
        condition:
            return header.type == "VariableExpr";
        end condition.
        then:
             var: VariableExpr <- assign.target;
             name <- var.name.value;
             varType <- st: resolve: name;
             
             if:
             condition:
                 return varType == "error";
             end condition.
             then:
                  # Implicit Declaration
                  st: define: name, valueType;
                  return valueType;
             end then.
             end if.
             
             if:
             condition:
                 return varType != valueType;
             end condition.
             then:
                  self: reportError: "Cannot assign " + valueType + " to variable '" + name + "' of type " + varType, var.name;
             end then.
             end if.
             return varType;
        end then.
        else:
             if:
             condition:
                 return header.type == "GetExpr" or header.type == "ArrayAccess";
             end condition.
             then:
                  # Support member assignment. 
                  # For now, we skip deep validation of property existence and just allow it.
                  self: checkExpression: assign.target;
                  return valueType;
             end then.
             else:
                  if:
                  condition:
                      return header.type == "ArrayAccess";
                  end condition.
                  then:
                       self: checkExpression: assign.target;
                       return valueType;
                  end then.
                  end if.
                  
                  self: reportError: "Invalid assignment target type " + header.type, nil;
                  return "error";
             end else.
             end if.
        end else.
        end if.
    end method.
    
    has method checkExprStmt: stmt: void* -> void:
        es: ExprStmt <- stmt;
        self: checkExpression: es.expr;
    end method.


    has method checkVarDecl: stmt: void* -> void:
        # Re-implementing checkVarDecl
        decl: LetStmt <- stmt;
        
        # Determine type
        declaredType: string <- decl.typeHint;
        
        if:
        condition:
            return decl.initializer != nil;
        end condition.
        then:
             inferredType: string <- self: checkExpression: decl.initializer;
             if:
             condition:
                 return declaredType == "";
             end condition.
             then:
                 declaredType <- inferredType;
             end then.
             else:
                  if:
                  condition:
                      return declaredType != inferredType;
                  end condition.
                  then:
                      self: reportError: "Variable '" + decl.name.value + "' expects " + declaredType + " but got " + inferredType, decl.name;
                  end then.
                  end if.
             end else.
             end if.
        end then.
        end if.
        
        st: SymbolTable <- self.symbols;
        print: "DEBUG: Defining variable: " + decl.name.value + " as " + declaredType;
        st: define: decl.name.value, declaredType;
    end method.

    has method checkMethodDecl: stmt: void* -> void:
        decl: MethodDecl <- stmt;
        st: SymbolTable <- self.symbols;
        
        # Define method in current scope (global)
        st: define: decl.name, "method";
        
        # Enter method scope
        st: enterScope;
        
        # Context
        if:
        condition:
            return decl.isStatic;
        end condition.
        then:
             self.currentMode <- "static";
        end then.
        else:
             self.currentMode <- "instance";
             if:
             condition:
                 return self.currentEntity != "";
             end condition.
             then:
                  st: define: "self", self.currentEntity;
             end then.
             end if.
        end else.
        end if.
        
        # Define parameters
        args: ASTList <- decl.params;
        if:
        condition:
            return args != nil;
        end condition.
        then:
            node: ASTNode <- args.head;
            loop:
                if:
                condition:
                    return node == nil;
                end condition.
                then:
                    break;
                end then.
                end if.
                
                param: FieldDecl <- node.value;
                # Params are FieldDecl with name/type
                st: define: param.name, param.fieldType;
                
                node <- node.next;
            end loop.
        end then.
        end if.
        
        # Check body
        self: checkBlock: decl.body;
        
        st: exitScope;
    end method.

    has method checkReturn: stmt: void* -> void:
        ret: ReturnStmt <- stmt;
        if:
        condition:
            return ret.value != nil;
        end condition.
        then:
             self: checkExpression: ret.value;
             # TODO: Check against enclosing method return type
        end then.
        end if.
    end method.

    has method checkIf: stmt: void* -> void:
        ifStmt: IfStmt <- stmt;
        condType <- self: checkExpression: ifStmt.condition;
        if:
        condition:
            return condType != "bool";
        end condition.
        then:
             self: reportError: "If condition must be bool, got " + condType, nil; 
        end then.
        end if.
        
        self: checkBlock: ifStmt.thenBranch;
        if:
        condition:
            return ifStmt.elseBranch != nil;
        end condition.
        then:
             # elseBranch can be Block or IfStmt (for else if)
             # We need to dispatch checkStatement to handle both recursion or block
             self: checkStatement: ifStmt.elseBranch;
        end then.
        end if.
    end method.
    
    has method checkWhile: stmt: void* -> void:
        w: WhileStmt <- stmt;
        condType <- self: checkExpression: w.condition;
        if:
        condition:
            return condType != "bool";
        end condition.
        then:
             self: reportError: "While condition must be bool, got " + condType, nil;
        end then.
        end if.
        self: checkBlock: w.body;
    end method.

    has method checkLoop: stmt: void* -> void:
        l: LoopStmt <- stmt;
        self: checkBlock: l.body;
    end method.

    has method checkBinary: expr: void* -> string:
        bin: BinaryExpr <- expr;
        leftType <- self: checkExpression: bin.left;
        rightType <- self: checkExpression: bin.right;
        
        if:
        condition:
            return leftType != rightType;
        end condition.
        then:
             # Relax for string concatenation
             if:
             condition:
                 return (leftType == "string" and rightType == "int") or (leftType == "int" and rightType == "string");
             end condition.
             then:
                  return "string";
             end then.
             end if.

             self: reportError: "Binary operand mismatch " + leftType + " vs " + rightType, bin.op;
             return "error";
        end then.
        end if.
        
        op <- bin.op.value;
        if:
        condition:
            return op == "==" or op == "!=" or op == "<" or op == ">" or op == "<=" or op == ">=";
        end condition.
        then:
             return "bool";
        end then.
        end if.
        
        return leftType;
    end method.

    has method checkUnary: expr: void* -> string:
        un: UnaryExpr <- expr;
        return self: checkExpression: un.right;
    end method.
    
    has method checkCall: expr: void* -> string:
        call: MethodCall <- expr;
        let methodName: string <- call.metTok.value;
        
        # 1. Resolve receiver type
        let receiverType: string <- "";
        if:
        condition:
            return call.receiver == nil;
        end condition.
        then:
             # Implicit self
             if:
             condition:
                 return self.currentEntity == "";
             end condition.
             then:
                  self: reportError: "Implicit call to '" + methodName + "' outside of entity context", call.metTok;
                  return "error";
             end then.
             end if.
             receiverType <- self.currentEntity;
        end then.
        else:
             receiverType <- self: checkExpression: call.receiver;
        end else.
        end if.
        
        if:
        condition:
            return receiverType == "error";
        end condition.
        then:
            return "error";
        end then.
        end if.
        
        # 2. Check arguments
        args: ASTList <- call.args;
        if:
        condition:
            return args != nil;
        end condition.
        then:
            node: ASTNode <- args.head;
            loop:
                if:
                condition:
                    return node == nil;
                end condition.
                then:
                    break;
                end then.
                end if.
                self: checkExpression: node.value;
                node <- node.next;
            end loop.
        end then.
        end if.
        
        # 3. Resolve method
        let retType: string <- self: findMember: receiverType, methodName;
        if:
        condition:
            return retType == "error";
        end condition.
        then:
             # Basic built-ins
             if:
             condition:
                 return methodName == "alloc";
             end condition.
             then:
                  return receiverType;
             end then.
             end if.
             if:
             condition:
                 return methodName == "print" or methodName == "free";
             end condition.
             then:
                  return "void";
             end then.
             end if.
             
             self: reportError: "Undefined method '" + methodName + "' on type " + receiverType, call.metTok;
             return "error";
        end then.
        end if.
        
        return retType; 
    end method.

    has method checkArrayAccess: expr: void* -> string:
        aa: ArrayAccess <- expr;
        self: checkExpression: aa.target;
        self: checkExpression: aa.index;
        return "void"; # Placeholder for element type
    end method.
    
    has method checkStructDecl: stmt: void* -> void:
        let decl: StructDecl <- stmt;
        let st: SymbolTable <- self.symbols;
        st: define: decl.name, "struct";
        
        # Register in globalTypes
        let list: ASTList <- self.globalTypes;
        let node: ASTNode <- ASTNode: new: decl, nil;
        if:
        condition:
            return list.head == nil;
        end condition.
        then:
             list.head <- node;
             list.tail <- node;
        end then.
        else:
             tail: ASTNode <- list.tail;
             tail.next <- node;
             list.tail <- node;
        end else.
        end if.
    end method.

    has method checkEntityDecl: stmt: void* -> void:
        let decl: EntityDecl <- stmt;
        let st: SymbolTable <- self.symbols;
        
        # Register Entity Name
        st: define: decl.name, "entity";
        self.currentEntity <- decl.name;
        
        # Register in globalTypes
        let list: ASTList <- self.globalTypes;
        let newNode: ASTNode <- ASTNode: new: decl, nil;
        if:
        condition:
            return list.head == nil;
        end condition.
        then:
             list.head <- newNode;
             list.tail <- newNode;
        end then.
        else:
             tail: ASTNode <- list.tail;
             tail.next <- newNode;
             list.tail <- newNode;
        end else.
        end if.
        
        # Check Methods
        let methodsList: ASTList <- decl.methods;
        if:
        condition:
            return methodsList != nil;
        end condition.
        then:
             let node: ASTNode <- methodsList.head;
             loop:
                 if:
                 condition:
                     return node == nil;
                 end condition.
                 then:
                     break;
                 end then.
                 end if.
                 if:
                 condition:
                     return node.value == nil;
                 end condition.
                 then:
                      node <- node.next;
                      continue;
                 end then.
                 end if.
                 self: checkMethodDecl: node.value;
                 node <- node.next;
             end loop.
        end then.
        end if.
        
        self.currentEntity <- "";
    end method.

    has method findType: name: string -> void*:
        # Detect Generic application: List<string>
        iLt: int <- Strings: indexOf: name, "<";
        if:
        condition:
            return iLt != -1;
        end condition.
        then:
             list: ASTList <- self.globalTypes;
             node: ASTNode <- list.head;
             loop:
                 if:
                 condition:
                     return node == nil;
                 end condition.
                 then:
                     break;
                 end then.
                 end if.
                 let nn: NamedNode <- node.value;
                 if:
                 condition:
                     return nn.name == name;
                 end condition.
                 then:
                     return node.value;
                 end then.
                 end if.
                 node <- node.next;
             end loop.
             
             # Not found, instantiate
             return self: instantiate: name.
        end then.
        end if.

        list: ASTList <- self.globalTypes;
        node: ASTNode <- list.head;
        loop:
            if:
            condition:
                return node == nil;
            end condition.
            then:
                break;
            end then.
            end if.
            
            let nn: NamedNode <- node.value;
            if:
            condition:
                return nn.name == name;
            end condition.
            then:
                return node.value;
            end then.
            end if.
            node <- node.next;
        end loop.
        return nil.
    end method.

    has method instantiate: fullTypeName: string -> void*:
        print: "Instantiating generic type: " + fullTypeName;
        iLt: int <- Strings: indexOf: fullTypeName, "<";
        baseName: string <- Strings: substring: fullTypeName, 0, iLt;
        
        argStr: string <- Strings: substring: fullTypeName, iLt + 1, Strings: length: fullTypeName - 1;
        
        template: void* <- self: findType: baseName;
        if:
        condition:
            return template == nil;
        end condition.
        then:
             print: "ERROR: Template not found: " + baseName;
             return nil.
        end then.
        end if.
        
        let clone: void* <- self: cloneNode: template;
        
        let tNamed: NamedNode <- template;
        let tParams: ASTList <- nil;
        if:
        condition:
            return tNamed.type == "EntityDecl";
        end condition.
        then:
             let ed: EntityDecl <- template;
             tParams <- ed.typeParams;
        end then.
        else:
             if:
             condition:
                 return tNamed.type == "StructDecl";
             end condition.
             then:
                  let sd: StructDecl <- template;
                  tParams <- sd.typeParams;
             end then.
             end if.
        end else.
        end if.
        
        if:
        condition:
            return tParams == nil;
        end condition.
        then:
             return clone.
        end then.
        end if.
        
        let pNode: ASTNode <- tParams.head;
        let pTok: Token <- pNode.value;
        let pName: string <- pTok.value;
        
        self: replaceTypes: clone, pName, argStr;
        
        let cNamed: NamedNode <- clone;
        cNamed.name <- fullTypeName;
        
        let gList: ASTList <- self.globalTypes;
        ASTList: add: gList, clone;
        
        return clone.
    end method.

    has method substituteType: t: string, param: string, arg: string -> string:
        if:
        condition:
            return t == param;
        end condition.
        then:
            return arg;
        end then.
        end if.
        return t.
    end method.

    has method replaceTypes: nodeVoid: void*, param: string, arg: string -> void:
        if:
        condition:
            return nodeVoid == nil;
        end condition.
        then:
            return;
        end then.
        end if.
        
        let header: NamedNode <- nodeVoid;
        let type: string <- header.type;
        
        if:
        condition:
            return type == "EntityDecl";
        end condition.
        then:
             let ed: EntityDecl <- nodeVoid;
             self: replaceTypesList: ed.fields, param, arg;
             self: replaceTypesList: ed.methods, param, arg;
             return.
        end then.
        end if.
        
        if:
        condition:
            return type == "StructDecl";
        end condition.
        then:
             let sd: StructDecl <- nodeVoid;
             self: replaceTypesList: sd.fields, param, arg;
             return.
        end then.
        end if.

        if:
        condition:
            return type == "FieldDecl";
        end condition.
        then:
             let fd: FieldDecl <- nodeVoid;
             fd.fieldType <- self: substituteType: fd.fieldType, param, arg;
             return.
        end then.
        end if.

        if:
        condition:
            return type == "MethodDecl";
        end condition.
        then:
             let md: MethodDecl <- nodeVoid;
             md.returnType <- self: substituteType: md.returnType, param, arg;
             self: replaceTypesList: md.params, param, arg;
             self: replaceTypes: md.body, param, arg;
             return.
        end then.
        end if.
        
        if:
        condition:
            return type == "Block";
        end condition.
        then:
             let b: Block <- nodeVoid;
             self: replaceTypesList: b.stmts, param, arg;
             return.
        end then.
        end if.

        if:
        condition:
            return type == "VariableExpr";
        end condition.
        then:
             let ve: VariableExpr <- nodeVoid;
             let tok: Token <- ve.name;
             if:
             condition:
                 return tok.value == param;
             end condition.
             then:
                  tok.value <- arg;
             end then.
             end if.
             return.
        end then.
        end if.

        # Handle more nodes recursively if needed
    end method.

    has method replaceTypesList: listVoid: void*, param: string, arg: string -> void:
        if:
        condition:
            return listVoid == nil;
        end condition.
        then:
            return;
        end then.
        end if.
        let list: ASTList <- listVoid;
        let node: ASTNode <- list.head;
        loop:
            if:
            condition:
                return node == nil;
            end condition.
            then:
                break;
            end then.
            end if.
            self: replaceTypes: node.value, param, arg;
            node <- node.next;
        end loop.
    end method.

    has method cloneNode: nodeVoid: void* -> void*:
        if:
        condition:
            return nodeVoid == nil;
        end condition.
        then:
            return nil.
        end then.
        end if.
        
        let header: NamedNode <- nodeVoid;
        let type: string <- header.type;
        
        if:
        condition:
            return type == "EntityDecl";
        end condition.
        then:
             let old: EntityDecl <- nodeVoid;
             let newD: EntityDecl <- EntityDecl: alloc;
             newD.type <- "EntityDecl";
             newD.name <- old.name;
             newD.fields <- self: cloneList: old.fields;
             newD.methods <- self: cloneList: old.methods;
             newD.typeParams <- old.typeParams; # Keep these as is for template identification if needed
             return newD.
        end then.
        end if.

        if:
        condition:
            return type == "StructDecl";
        end condition.
        then:
             let old: StructDecl <- nodeVoid;
             let newD: StructDecl <- StructDecl: alloc;
             newD.type <- "StructDecl";
             newD.name <- old.name;
             newD.fields <- self: cloneList: old.fields;
             newD.typeParams <- old.typeParams;
             return newD.
        end then.
        end if.

        if:
        condition:
            return type == "FieldDecl";
        end condition.
        then:
             let old: FieldDecl <- nodeVoid;
             let newD: FieldDecl <- FieldDecl: alloc;
             newD.type <- "FieldDecl";
             newD.name <- old.name;
             newD.fieldType <- old.fieldType;
             return newD.
        end then.
        end if.

        if:
        condition:
            return type == "MethodDecl";
        end condition.
        then:
             let old: MethodDecl <- nodeVoid;
             let newD: MethodDecl <- MethodDecl: alloc;
             newD.type <- "MethodDecl";
             newD.name <- old.name;
             newD.isStatic <- old.isStatic;
             newD.returnType <- old.returnType;
             newD.params <- self: cloneList: old.params;
             newD.body <- self: cloneNode: old.body;
             return newD.
        end then.
        end if.
        
        if:
        condition:
            return type == "Block";
        end condition.
        then:
             let old: Block <- nodeVoid;
             let newD: Block <- Block: alloc;
             newD.type <- "Block";
             newD.stmts <- self: cloneList: old.stmts;
             newD.terminatedByDot <- old.terminatedByDot;
             return newD.
        end then.
        end if.

        if:
        condition:
            return type == "VariableExpr";
        end condition.
        then:
             let old: VariableExpr <- nodeVoid;
             let newV: VariableExpr <- VariableExpr: alloc;
             newV.type <- "VariableExpr";
             let oldTok: Token <- old.name;
             let newTok: Token <- Token: alloc;
             newTok.type <- oldTok.type;
             newTok.value <- oldTok.value;
             newTok.line <- oldTok.line;
             newTok.column <- oldTok.column;
             newTok.offset <- oldTok.offset;
             newV.name <- newTok;
             return newV.
        end then.
        end if.

        return nodeVoid.
    end method.

    has method cloneList: listVoid: void* -> void*:
        if:
        condition:
            return listVoid == nil;
        end condition.
        then:
            return nil.
        end then.
        end if.
        let oldList: ASTList <- listVoid;
        let newList: ASTList <- ASTList: new: nil, nil;
        let oldNode: ASTNode <- oldList.head;
        loop:
            if:
            condition:
                return oldNode == nil;
            end condition.
            then:
                break;
            end then.
            end if.
            let clonedVal: void* <- self: cloneNode: oldNode.value;
            ASTList: add: newList, clonedVal;
            oldNode <- oldNode.next;
        end loop.
        return newList.
    end method.

    has method findMember: typeName: string, memberName: string -> string:
        # Search for field or method in entity/struct
        typeDecl: void* <- self: findType: typeName;
        if:
        condition:
            return typeDecl == nil;
        end condition.
        then:
            return "error";
        end then.
        end if.
        
        header: Header <- typeDecl;
        if:
        condition:
            return header.type == "EntityDecl";
        end condition.
        then:
             ent: EntityDecl <- typeDecl;
             # Check fields
             fieldsList: ASTList <- ent.fields;
             if:
             condition:
                 return fieldsList != nil;
             end condition.
             then:
                  fnode: ASTNode <- fieldsList.head;
                  loop:
                      if:
                      condition:
                          return fnode == nil;
                      end condition.
                      then:
                          break;
                      end then.
                      end if.
                      f: FieldDecl <- fnode.value;
                      if:
                      condition:
                          return f.name == memberName;
                      end condition.
                      then:
                          return f.fieldType;
                      end then.
                      end if.
                      fnode <- fnode.next;
                  end loop.
             end then.
             end if.
             # Check methods
             methodsList: ASTList <- ent.methods;
             if:
             condition:
                 return methodsList != nil;
             end condition.
             then:
                  mnode: ASTNode <- methodsList.head;
                  loop:
                      if:
                      condition:
                          return mnode == nil;
                      end condition.
                      then:
                          break;
                      end then.
                      end if.
                      m: MethodDecl <- mnode.value;
                      if:
                      condition:
                          return m.name == memberName;
                      end condition.
                      then:
                          return m.returnType;
                      end then.
                      end if.
                      mnode <- mnode.next;
                  end loop.
             end then.
             end if.
        end then.
        else:
             if:
             condition:
                 return header.type == "StructDecl";
             end condition.
             then:
                  str: StructDecl <- typeDecl;
                  fieldsList: ASTList <- str.fields;
                  if:
                  condition:
                      return fieldsList != nil;
                  end condition.
                  then:
                       fnode: ASTNode <- fieldsList.head;
                       loop:
                           if:
                           condition:
                               return fnode == nil;
                           end condition.
                           then:
                               break;
                           end then.
                           end if.
                           f: FieldDecl <- fnode.value;
                           if:
                           condition:
                               return f.name == memberName;
                           end condition.
                           then:
                               return f.fieldType;
                           end then.
                           end if.
                           fnode <- fnode.next;
                       end loop.
                  end then.
                  end if.
             end then.
             end if.
        end else.
        end if.
        return "error";
    end method.

    has method check: program: void* -> void:
        prog: Program <- program;
        if:
        condition:
            return prog == nil;
        end condition.
        then:
            return;
        end then.
        end if.
        
        print: "DEBUG: TypeChecker: Starting check";
        # Module
        self: checkModule: prog.module;
        print: "DEBUG: TypeChecker: Module checked";
        
        # Statements (Register all types first in a pass?)
        # For simplicity, we assume declarations are before usage or we do a pre-pass;
        # Actually, let's just use the current order;
        
        self: checkBlock: prog.stmts;
        print: "DEBUG: TypeChecker: Program checked";
    end method.

end Entity.
