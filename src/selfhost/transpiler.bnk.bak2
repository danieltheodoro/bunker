module bunker;

include src.selfhost.ast;

# Simple C Transpiler
# For now, we will use direct string concatenation or simple printing.
# Ideally, we would have a StringBuilder.

Entity CTranspiler:
    
    # State
    has output: string;
    has indentLevel: int;
    has symbols: void*; # SymbolTable*
    has currentEntity: string;
    
    has static method new: -> CTranspiler:
        t: CTranspiler <- CTranspiler: alloc;
        t.output <- "";
        t.indentLevel <- 0;
        t.symbols <- nil;
        t.currentEntity <- "";
        return t.
    end method.

    has method mapType: typeName: string -> string:
        if typeName == "int": return "long long"; end if.
        if typeName == "string": return "char*"; end if.
        if typeName == "bool": return "bool"; end if.
        if typeName == "void": return "void"; end if.
        return "void*"; # Fallback
    end method.

    has method emit: text: string -> void:
        self.output <- self.output + text;
    end method.

    has method emitLine: text: string -> void:
        i: int <- 0;
        loop:
            if i >= self.indentLevel: break; end if.
            self: emit: "    ";
            i <- i + 1;
        end loop.
        self: emit: text + "\n";
    end method.

    has method indent -> void:
        self.indentLevel <- self.indentLevel + 1;
    end method.

    has method dedent -> void:
        self.indentLevel <- self.indentLevel - 1;
    end method.

    has method transpile: node: void* -> void:
        self: emitProgram: node;
    end method.

    has method emitProgram: node: void* -> void:
        prog: Program <- node;
        self: emitLine: "// Generated by Bunker Self-Hosted Compiler";
        self: emitLine: "#include <stdio.h>";
        self: emitLine: "#include <stdlib.h>";
        self: emitLine: "#include <stdbool.h>";
        self: emitLine: "#include <string.h>";
        self: emitLine: "#include <stdint.h>";
        self: emitLine: "";
        self: emitLine: "typedef void* (*BunkerFunc)();";
        self: emitLine: "void gc_free(void* ptr);";
        self: emitLine: "";

        list: ASTList <- prog.stmts;
        n: ASTNode <- list.head;
        loop:
            if n == nil: break; end if.
            h: Header <- n.value;
            if h.type == "EntityDecl" or h.type == "ModuleDecl":
                self: emitStatement: n.value;
            end if.
            n <- n.next;
        end loop.

        self: emitLine: "";
        self: emitLine: "int main(int argc, char** argv) {";
        self: indent;
        self: emitLine: "volatile void* dummy; gc_stack_bottom = (void*)&dummy;";
        self: emitLine: "GC_INIT();";
        
        # Second pass: emit top-level statements (inside main)
        nm: ASTNode <- list.head;
        loop:
            if nm == nil: break; end if.
            hm: Header <- nm.value;
            if hm.type != "EntityDecl" and hm.type != "ModuleDecl" and hm.type != "IncludeDecl":
                self: emitStatement: nm.value;
            end if.
            nm <- nm.next;
        end loop.

        # Look for Main.main
        self: emitLine: "return Main_main(NULL, argc, (void**)argv);";
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitStatement: stmt: void* -> void:
        head: Header <- stmt;
        type: string <- head.type;
        
        if type == "LetStmt": self: emitLetStmt: stmt; return; end if.
        if type == "ExprStmt": self: emitExprStmt: stmt; return; end if.
        if type == "ReturnStmt": self: emitReturnStmt: stmt; return; end if.
        if type == "IfStmt": self: emitIfStmt: stmt; return; end if.
        if type == "WhileStmt": self: emitWhileStmt: stmt; return; end if.
        if type == "LoopStmt": self: emitLoopStmt: stmt; return; end if.
        if type == "ModuleDecl": self: emitModuleDecl: stmt; return; end if.
        if type == "EntityDecl": self: emitEntityDecl: stmt; return; end if.
        if type == "MethodDecl": self: emitMethodDecl: stmt; return; end if.
        if type == "ScopedStmt": self: emitScopedStmt: stmt; return; end if.
        if type == "IncludeDecl": self: emitIncludeDecl: stmt; return; end if.
        if type == "UnabstractedBlock": self: emitUnabstractedBlock: stmt; return; end if.
        if type == "AsmStmt": self: emitAsmStmt: stmt; return; end if.
        
        self: emitLine: "// Unknown stmt type: " + type;
    end method.

    has method emitLetStmt: stmt: void* -> void:
        let: LetStmt <- stmt;
        if (let.typeHint != ""):
             self: emit: (self: mapType: let.typeHint) + " ";
        else:
             self: emit: "void* "; # Default to void* for untyped 'let'
        end if.
        self: emit: let.name.value;
        self: emit: " = ";
        self: emitExpression: let.initializer;
        self: emitLine: ";";
    end method.

    has method emitExprStmt: stmt: void* -> void:
        exprStmt: ExprStmt <- stmt;
        self: emitExpression: exprStmt.expr;
        self: emitLine: ";";
    end method.

    has method emitReturnStmt: stmt: void* -> void:
        ret: ReturnStmt <- stmt;
        self: emit: "return ";
        if ret.value != nil:
             self: emitExpression: ret.value;
        end if.
        self: emitLine: ";";
    end method.

    has method emitExpression: expr: void* -> void:
        head: Header <- expr;
        type: string <- head.type;
        
        if type == "BinaryExpr": self: emitBinary: expr; return; end if.
        if type == "LiteralExpr": self: emitLiteral: expr; return; end if.
        if type == "VariableExpr": self: emitVariable: expr; return; end if.
        if type == "MethodCall": self: emitCall: expr; return; end if.
        if type == "UnaryExpr": self: emitUnary: expr; return; end if.
        if type == "GetExpr": self: emitGetExpr: expr; return; end if.
        if type == "GroupingExpr": self: emitGrouping: expr; return; end if.
        if type == "AssignExpr": self: emitAssign: expr; return; end if.
        if type == "LetStmt": self: emitLetStmt: expr; return; end if.
        
        self: emit: "// Unknown expr: " + type;
    end method.

    has method emitLiteral: expr: void* -> void:
        lit: LiteralExpr <- expr;
        if lit.literalType == "string":
             self: emit: "\"" + lit.tok.value + "\"";
        else:
             self: emit: lit.tok.value;
        end if.
    end method.

    has method emitVariable: expr: void* -> void:
        var: VariableExpr <- expr;
        self: emit: var.name.value;
    end method.

    has method emitBinary: expr: void* -> void:
        bin: BinaryExpr <- expr;
        # Removed extra parens to avoid gcc warnings in if/while
        self: emitExpression: bin.left;
        self: emit: " " + bin.op.value + " ";
        self: emitExpression: bin.right;
    end method.

    has method emitAssign: expr: void* -> void:
        assign: AssignExpr <- expr;
        self: emitExpression: assign.target;
        self: emit: " = ";
        self: emitExpression: assign.value;
    end method.

    has method emitUnary: expr: void* -> void:
        u: UnaryExpr <- expr;
        self: emit: u.op.value;
        self: emitExpression: u.right;
    end method.

    has method emitGetExpr: expr: void* -> void:
        get: GetExpr <- expr;
        self: emitExpression: get.object;
        self: emit: "->" + get.nameTok.value;
    end method.

    has method emitGrouping: expr: void* -> void:
        group: GroupingExpr <- expr;
        self: emit: "(";
        self: emitExpression: group.expression;
        self: emit: ")";
    end method.

    has method emitCall: expr: void* -> void:
        let call: MethodCall <- expr;
        let st: SymbolTable <- nil;
        let lc: ASTList <- nil;
        let nc: ASTNode <- nil;
        let first: bool <- true;
        
        if call.metTok.value == "print":
             let argType: string <- "string";
             if call.args != nil:
                  let l: ASTList <- call.args;
                  if l.head != nil:
                      let n: ASTNode <- l.head;
                      
                      # Try to resolve type of the argument expression
                      if self.symbols != nil:
                          st <- self.symbols;
                          
                          # We need to know what kind of expression it is to resolve its type
                          # For now, let's keep it simple: if it's a VariableExpr, resolve it.
                          # If it's a BinaryExpr, assume int for now (simplification).
                          # If it's a LiteralExpr, use its type.
                          let h: Header <- n.value;
                          if h.type == "VariableExpr":
                              let v: VariableExpr <- n.value;
                              argType <- st: resolve: v.name.value;
                          else:
                              if h.type == "LiteralExpr":
                                  let lit: LiteralExpr <- n.value;
                                  argType <- lit.literalType;
                              else:
                                  if h.type == "BinaryExpr":
                                       argType <- "int";
                                  end if.
                          end if.
                      
                      if argType == "int":
                          self: emit: "printf(\"%lld\\n\", (long long)";
                      else:
                          if argType == "bool":
                              self: emit: "printf(\"%s\\n\", (";
                              self: emitExpression: n.value;
                              self: emit: " ? \"true\" : \"false\")";
                              return;
                          else:
                              self: emit: "printf(\"%s\\n\", (char*)";
                          end if.
                      self: emitExpression: n.value;
                  end if.
             self: emit: ")";
             return;
        end if.

        # Generic Call or Static Call
        let isStatic: bool <- false;
        let entityName: string <- "";
        
        if call.receiver != nil:
             let hRec: Header <- call.receiver;
             if hRec.type == "VariableExpr":
                  let vRec: VariableExpr <- call.receiver;
                  if vRec.name.value == "Memory":
                       isStatic <- true;
                       entityName <- "Memory";
                  else:
                       if self.symbols != nil:
                            st <- self.symbols;
                            let resType: string <- st: resolve: vRec.name.value;
                            if resType == "entity":
                                 isStatic <- true;
                                 entityName <- vRec.name.value;
                            end if.
                  end if.
        end if.

        if isStatic:
             if entityName == "Memory":
                  if call.metTok.value == "free":
                       self: emit: "gc_free(";
                       if call.args != nil:
                            lc <- call.args;
                            nc <- lc.head;
                            if nc != nil: self: emitExpression: nc.value; end if.
                       self: emit: ")";
                       return.
                  end if.
             self: emit: entityName + "_" + call.metTok.value + "(NULL";
             if (call.args != nil):
                  lc <- call.args;
                  nc <- lc.head;
                  loop:
                       if nc == nil: break; end if.
                       self: emit: ", ";
                       self: emitExpression: nc.value;
                       nc <- nc.next;
                  end loop.
             end if.
             self: emit: ")";
        else:
             if call.receiver != nil:
                  # Instance Method Call Placeholder
                  self: emit: "MethodCall_Generic(";
                  self: emitExpression: call.receiver;
                   self: emit: ", \"" + call.metTok.value + "\")";
             else:
                  # Simple function call (not used much in Bunker except for print/builtins)
                   self: emit: call.metTok.value + "(";
                  if (call.args != nil):
                       lc <- call.args;
                       nc <- lc.head;
                       first <- true;
                       loop:
                           if nc == nil: break; end if.
                           if (!first): self: emit: ", "; end if.
                           self: emitExpression: nc.value;
                           first <- false;
                           nc <- nc.next;
                       end loop.
                  end if.
                  self: emit: ")";
             end if.
                                             end if.
                                         end if.
                                     end if.
                                 end if.
                             end if.
                         end if.
                     end if.
                 end if.
             end if.
    end method.

    has method emitIfStmt: stmt: void* -> void:
        ifRec: IfStmt <- stmt;
        self: emit: "if (";
        self: emitExpression: ifRec.condition;
        self: emit: ")";
        self: emitLine: " {";
        self: indent;
        self: emitBlock: ifRec.thenBranch;
        self: dedent;
        if ifRec.elseBranch != nil:
             self: emitLine: "} else {";
             self: indent;
             self: emitBlock: ifRec.elseBranch;
             self: dedent;
        end if.
        self: emitLine: "}";
    end method.

    has method emitWhileStmt: stmt: void* -> void:
        w: WhileStmt <- stmt;
        self: emit: "while (";
        self: emitExpression: w.condition;
        self: emit: ")";
        self: emitLine: " {";
        self: indent;
        self: emitBlock: w.body;
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitLoopStmt: stmt: void* -> void:
        l: LoopStmt <- stmt;
        self: emitLine: "while (true) {";
        self: indent;
        self: emitBlock: l.body;
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitScopedStmt: stmt: void* -> void:
        s: ScopedStmt <- stmt;
        self: emitLine: "{ /* scoped */";
        self: indent;
        self: emitBlock: s.body;
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitBlock: stmt: void* -> void:
        b: Block <- stmt;
        l: ASTList <- b.stmts;
        if l != nil:
             n: ASTNode <- l.head;
             loop:
                 if n == nil: break; end if.
                 self: emitStatement: n.value;
                 n <- n.next;
             end loop.
        end if.
    end method.

    has method emitModuleDecl: node: void* -> void:
        mod: ModuleDecl <- node;
        self: emitLine: "// Module: " + mod.name;
    end method.

    has method emitEntityDecl: node: void* -> void:
        ent: EntityDecl <- node;
        self: emitLine: "// Entity: " + ent.name;
        
        # Emit struct for entity fields
        self: emitLine: "struct " + ent.name + " {";
        self: indent;
        
        # Every entity has a 'type' field for simple RTTI if needed
        self: emitLine: "char* type;";
        
        if ent.fields != nil:
            flist: ASTList <- ent.fields;
            fn: ASTNode <- flist.head;
            loop:
                if fn == nil: break; end if.
                field: FieldDecl <- fn.value;
                self: emitLine: (self: mapType: field.fieldType) + " " + field.name + ";";
                fn <- fn.next;
            end loop.
        end if.
        self: dedent;
        self: emitLine: "};";
        
        oldEntity <- self.currentEntity;
        self.currentEntity <- ent.name;
        
        list: ASTList <- ent.methods;
        if list != nil:
            n: ASTNode <- list.head;
            loop:
                if n == nil: break; end if.
                self: emitMethodDecl: n.value;
                n <- n.next;
            end loop.
        end if.
        
        self.currentEntity <- oldEntity;
    end method.

    has method emitMethodDecl: node: void* -> void:
        meth: MethodDecl <- node;
        
        # Mangled Name
        mangledName <- self.currentEntity + "_" + meth.name;
        
        # Return Type
        retType <- self: mapType: meth.returnType;
        
        # Signature
        self: emit: retType + " " + mangledName + "(";
        
        # Parameters
        self: emit: "void* _self"; # Every method gets _self
        
        params: ASTList <- meth.params;
        if params != nil:
            n: ASTNode <- params.head;
            loop:
                if n == nil: break; end if.
                p: FieldDecl <- n.value;
                self: emit: ", " + (self: mapType: p.fieldType) + " " + p.name;
                n <- n.next;
            end loop.
        end if.
        
        self: emitLine: ") {";
        self: indent;
        
        # Cast _self to entity type
        self: emitLine: "struct " + self.currentEntity + "* self = (struct " + self.currentEntity + "*)_self;";
        
        # Body
        self: emitBlock: meth.body;
        
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitIncludeDecl: node: void* -> void:
        inc: IncludeDecl <- node;
        self: emitLine: "// Include: " + inc.path;
    end method.

    has method emitUnabstractedBlock: node: void* -> void:
        un: UnabstractedBlock <- node;
        self: emitBlock: un.body;
    end method.

    has method emitAsmStmt: node: void* -> void:
        as: AsmStmt <- node;
        if as.target == "c":
             self: emitLine: as.code;
        end if.
    end method.

end Entity.
