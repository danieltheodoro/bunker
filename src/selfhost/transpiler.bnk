module bunker;

include src.selfhost.ast;

# Simple C Transpiler
# For now, we will use direct string concatenation or simple printing.
# Ideally, we would have a StringBuilder.

Entity CTranspiler:
    
    # State
    has output: void*; # ASTList of strings
    has outputTail: void*; # ASTNode*
    has indentLevel: int;
    has symbols: void*; # SymbolTable*
    has currentEntity: string;
    
    has static method new: -> CTranspiler:
        t: CTranspiler <- CTranspiler: alloc;
        t.output <- ASTList: new: nil, nil;
        t.outputTail <- nil;
        t.indentLevel <- 0;
        t.symbols <- nil;
        t.currentEntity <- "";
        return t.
    end method.

    has method mapType: typeName: string -> string:
        if:
        condition:
            return typeName == "int";
        end condition.
        then:
            return "long long";
        end then.
        end if.
        if:
        condition:
            return typeName == "string";
        end condition.
        then:
            return "char*";
        end then.
        end if.
        if:
        condition:
            return typeName == "bool";
        end condition.
        then:
            return "bool";
        end then.
        end if.
        if:
        condition:
            return typeName == "void";
        end condition.
        then:
            return "void";
        end then.
        end if.
        return "void*"; # Fallback
    end method.

    has method emit: text: string -> void:
        let node: ASTNode <- ASTNode: new: text, nil;
        let list: ASTList <- self.output;
        if:
        condition:
            return list.head == nil;
        end condition.
        then:
            list.head <- node;
            list.tail <- node;
            self.outputTail <- node;
        end then.
        else:
            let tail: ASTNode <- self.outputTail;
            tail.next <- node;
            self.outputTail <- node;
        end else.
        end if.
    end method.

    has method emitLine: text: string -> void:
        i: int <- 0;
        loop:
            if:
            condition:
                return i >= self.indentLevel;
            end condition.
            then:
                break;
            end then.
            end if.
            self: emit: "    ";
            i <- i + 1;
        end loop.
        self: emit: text + "\n";
    end method.

    has method indent -> void:
        self.indentLevel <- self.indentLevel + 1;
    end method.

    has method dedent -> void:
        self.indentLevel <- self.indentLevel - 1;
    end method.

    has method transpile: node: void* -> void:
        self: emitProgram: node;
    end method.

    has method emitProgram: node: void* -> void:
        prog: Program <- node;
        self: emitLine: "// Generated by Bunker Self-Hosted Compiler";
        self: emitLine: "#include \"runtime.h\"";
        self: emitLine: "";

        list: ASTList <- prog.stmts;
        n: ASTNode <- list.head;
        loop:
            if:
            condition:
                return n == nil;
            end condition.
            then:
                break;
            end then.
            end if.
            h: Header <- n.value;
            if:
            condition:
                return h.type == "EntityDecl" or h.type == "ModuleDecl";
            end condition.
            then:
                self: emitStatement: n.value;
            end then.
            end if.
            n <- n.next;
        end loop.

        self: emitLine: "";
        self: emitLine: "int main(int argc, char** argv) {";
        self: indent;
        self: emitLine: "volatile void* dummy; gc_stack_bottom = (void*)&dummy;";
        self: emitLine: "GC_INIT();";
        
        # Second pass: emit top-level statements (inside main)
        nm: ASTNode <- list.head;
        loop:
            if:
            condition:
                return nm == nil;
            end condition.
            then:
                break;
            end then.
            end if.
            hm: Header <- nm.value;
            if:
            condition:
                return hm.type != "EntityDecl" and hm.type != "ModuleDecl" and hm.type != "IncludeDecl" and hm.type != "ImportDecl";
            end condition.
            then:
                self: emitStatement: nm.value;
            end then.
            end if.
            nm <- nm.next;
        end loop.

        # Look for Main_main
        self: emitLine: "return Main_main(NULL, argc, (void**)argv);";
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitStatement: stmt: void* -> void:
        head: Header <- stmt;
        type: string <- head.type; print: "DEBUG: emitStatement type=" + type;
        
        if:
        condition:
            return type == "LetStmt";
        end condition.
        then:
            self: emitLetStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "ExprStmt";
        end condition.
        then:
            self: emitExprStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "ReturnStmt";
        end condition.
        then:
            self: emitReturnStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "IfStmt";
        end condition.
        then:
            self: emitIfStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "WhileStmt";
        end condition.
        then:
            self: emitWhileStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "LoopStmt";
        end condition.
        then:
            self: emitLoopStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "ModuleDecl";
        end condition.
        then:
            self: emitModuleDecl: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "EntityDecl";
        end condition.
        then:
            self: emitEntityDecl: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "MethodDecl";
        end condition.
        then:
            self: emitMethodDecl: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "ScopedStmt";
        end condition.
        then:
            self: emitScopedStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "IncludeDecl";
        end condition.
        then:
            self: emitIncludeDecl: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "UnabstractedBlock";
        end condition.
        then:
            self: emitUnabstractedBlock: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "AsmStmt";
        end condition.
        then:
            self: emitAsmStmt: stmt; return;
        end then.
        end if.
        
        if:
        condition:
            return type == "ImportDecl";
        end condition.
        then:
            self: emitImportDecl: stmt; return;
        end then.
        end if.
        
        self: emitLine: "// Unknown stmt type: " + type;
    end method.

    has method emitLetStmt: stmt: void* -> void:
        let letNode: LetStmt <- stmt;
        if:
        condition:
            return (letNode.typeHint != "");
        end condition.
        then:
             self: emit: (self: mapType: letNode.typeHint) + " ";
        end then.
        else:
             self: emit: "void* "; # Default to void* for untyped 'let'
             end else.
        end if.
        self: emit: letNode.name.value;
        self: emit: " = ";
        self: emitExpression: letNode.initializer;
        self: emitLine: ";";
    end method.

    has method emitExprStmt: stmt: void* -> void:
        exprStmt: ExprStmt <- stmt;
        self: emitExpression: exprStmt.expr;
        self: emitLine: ";";
    end method.

    has method emitReturnStmt: stmt: void* -> void:
        ret: ReturnStmt <- stmt;
        self: emit: "return ";
        if:
        condition:
            return ret.value != nil;
        end condition.
        then:
             self: emitExpression: ret.value;
        end then.
        end if.
        self: emitLine: ";";
    end method.

    has method emitExpression: expr: void* -> void:
        head: Header <- expr;
        type: string <- head.type; print: "DEBUG: emitExpression type=" + type;
        
        print: "DEBUG: emitStatement type=" + type;
        if:
        condition:
            return type == "BinaryExpr";
        end condition.
        then:
            self: emitBinary: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "LiteralExpr";
        end condition.
        then:
            self: emitLiteral: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "VariableExpr";
        end condition.
        then:
            self: emitVariable: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "MethodCall";
        end condition.
        then:
            self: emitCall: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "UnaryExpr";
        end condition.
        then:
            self: emitUnary: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "GetExpr";
        end condition.
        then:
            self: emitGetExpr: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "GroupingExpr";
        end condition.
        then:
            self: emitGrouping: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "AssignExpr";
        end condition.
        then:
            self: emitAssign: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "LetStmt";
        end condition.
        then:
            self: emitLetStmt: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "ArrayAccess";
        end condition.
        then:
            self: emitArrayAccess: expr; return;
        end then.
        end if.
        
        self: emit: "// Unknown expr: " + type;
    end method.

    has method emitLiteral: expr: void* -> void:
        lit: LiteralExpr <- expr; print: "DEBUG: emitLiteral val='" + lit.tok.value + "' type=" + lit.literalType;
        if:
        condition:
            return lit.literalType == "string";
        end condition.
        then:
             self: emit: "\"" + lit.tok.value + "\"";
        print: "DEBUG: emitLiteral val='" + lit.tok.value + "' type=" + lit.literalType;
        end then.
        else:
             self: emit: lit.tok.value;
             end else.
        end if.
    end method.

    has method emitVariable: expr: void* -> void:
        var: VariableExpr <- expr;
        self: emit: var.name.value;
    end method.

    has method emitBinary: expr: void* -> void:
        bin: BinaryExpr <- expr;
        # Removed extra parens to avoid gcc warnings in if/while
        self: emitExpression: bin.left;
        self: emit: " " + bin.op.value + " ";
        self: emitExpression: bin.right;
    end method.

    has method emitAssign: expr: void* -> void:
        assign: AssignExpr <- expr;
        self: emitExpression: assign.target;
        self: emit: " = ";
        self: emitExpression: assign.value;
    end method.

    has method emitUnary: expr: void* -> void:
        u: UnaryExpr <- expr;
        self: emit: u.op.value;
        self: emitExpression: u.right;
    end method.

    has method emitGetExpr: expr: void* -> void:
        get: GetExpr <- expr;
        self: emitExpression: get.object;
        self: emit: "->" + get.nameTok.value;
    end method.

    has method emitGrouping: expr: void* -> void:
        group: GroupingExpr <- expr;
        self: emit: "(";
        self: emitExpression: group.expression;
        self: emit: ")";
    end method.

    has method emitArrayAccess: expr: void* -> void:
        aa: ArrayAccess <- expr;
        # Since we don't know the type of the array easily here, we use a generic macro or cast
        # In Bunker, Array<T> is usually BunkerArray*
        self: emit: "((void**)((BunkerArray*)";
        self: emitExpression: aa.target;
        self: emit: ")->data)[(int)";
        self: emitExpression: aa.index;
        self: emit: "]";
    end method.

    has method emitCall: expr: void* -> void:
        let call: MethodCall <- expr;
        let st: SymbolTable <- nil;
        let lc: ASTList <- nil;
        let nc: ASTNode <- nil;
        let first: bool <- true;
        
        if:
        condition:
            return call.metTok.value == "print";
        end condition.
        then:
            let argType: string <- "string";
            if:
            condition:
                return call.args != nil;
            end condition.
            then:
                let l: ASTList <- call.args;
                if:
                condition:
                    return l.head != nil;
                end condition.
                then:
                    let n: ASTNode <- l.head;
                    
                    if:
                    condition:
                        return self.symbols != nil;
                    end condition.
                    then:
                        let st_print: SymbolTable <- self.symbols;
                        let h: Header <- n.value;
                        if:
                        condition:
                            return h.type == "VariableExpr";
                        end condition.
                        then:
                            let v: VariableExpr <- n.value;
                            argType <- st_print: resolve: v.name.value;
                        end then.
                        else:
                            if:
                            condition:
                                return h.type == "LiteralExpr";
                            end condition.
                            then:
                                let lit: LiteralExpr <- n.value;
                                argType <- lit.literalType;
                            end then.
                            else:
                                if:
                                condition:
                                    return h.type == "BinaryExpr";
                                end condition.
                                then:
                                    argType <- "int";
                                end then.
                                end if.
                             end else.
                             end if.
                         end else.
                         end if.
                    end then.
                    end if.
                    
                    if:
                    condition:
                        return argType == "int";
                    end condition.
                    then:
                        self: emit: "printf(\"%lld\\n\", (long long)";
                    end then.
                    else:
                        if:
                        condition:
                            return argType == "bool";
                        end condition.
                        then:
                            self: emit: "printf(\"%s\\n\", (";
                            self: emitExpression: n.value;
                            self: emit: " ? \"true\" : \"false\")";
                            self: emit: ")";
                            return.
                        end then.
                        else:
                            self: emit: "printf(\"%s\\n\", (char*)";
                         end else.
                         end if.
                     end else.
                     end if.
                    self: emitExpression: n.value;
                end then.
                end if.
            end then.
            end if.
            self: emit: ")";
            return.
        end then.
        end if.

        # Generic Call or Static Call
        let isStatic: bool <- false;
        let entityName: string <- "";
        
        if:
        condition:
            return call.receiver != nil;
        end condition.
        then:
            let hRec: Header <- call.receiver;
            if:
            condition:
                return hRec.type == "VariableExpr";
            end condition.
            then:
                let vRec: VariableExpr <- call.receiver;
                if:
                condition:
                    return vRec.name.value == "Memory";
                end condition.
                then:
                    isStatic <- true;
                    entityName <- "Memory";
                end then.
                else:
                    if:
                    condition:
                        return self.symbols != nil;
                    end condition.
                    then:
                        let st2: SymbolTable <- self.symbols;
                        let resType: string <- st2: resolve: vRec.name.value;
                        if:
                        condition:
                            return resType == "entity";
                        end condition.
                        then:
                            isStatic <- true;
                            entityName <- vRec.name.value;
                        end then.
                        end if.
                    end then.
                    end if.
                 end else.
                 end if.
            end then.
            end if.
        end then.
        end if.

        if:
        condition:
            return isStatic;
        end condition.
        then:
            if:
            condition:
                return entityName == "Memory";
            end condition.
            then:
                if:
                condition:
                    return call.metTok.value == "free";
                end condition.
                then:
                    self: emit: "gc_free(";
                    if:
                    condition:
                        return call.args != nil;
                    end condition.
                    then:
                        let lc2: ASTList <- call.args;
                        let nc2: ASTNode <- lc2.head;
                        if:
                        condition:
                            return nc2 != nil;
                        end condition.
                        then:
                            self: emitExpression: nc2.value;
                        end then.
                        end if.
                    end then.
                    end if.
                    self: emit: ")";
                    return.
                end then.
                end if.
            end then.
            end if.
            
            self: emit: entityName + "_" + call.metTok.value + "(NULL";
            if:
            condition:
                return call.args != nil;
            end condition.
            then:
                let lc3: ASTList <- call.args;
                let nc3: ASTNode <- lc3.head;
                loop:
                    if:
                    condition:
                        return nc3 == nil;
                    end condition.
                    then:
                        break;
                    end then.
                    end if.
                    self: emit: ", ";
                    self: emitExpression: nc3.value;
                    nc3 <- nc3.next;
                end loop.
            end then.
            end if.
            self: emit: ")";
        end then.
        else:
            if:
            condition:
                return call.receiver != nil;
            end condition.
            then:
                self: emit: "MethodCall_Generic(";
                self: emitExpression: call.receiver;
                self: emit: ", \"" + call.metTok.value + "\")";
            end then.
            else:
                self: emit: call.metTok.value + "(";
                if:
                condition:
                    return call.args != nil;
                end condition.
                then:
                    let lc4: ASTList <- call.args;
                    let nc4: ASTNode <- lc4.head;
                    let firstCall: bool <- true;
                    loop:
                        if:
                        condition:
                            return nc4 == nil;
                        end condition.
                        then:
                            break;
                        end then.
                        end if.
                        if:
                        condition:
                            return (firstCall == false);
                        end condition.
                        then:
                            self: emit: ", ";
                        end then.
                        end if.
                        self: emitExpression: nc4.value;
                        firstCall <- false;
                        nc4 <- nc4.next;
                    end loop.
                end then.
                end if.
                self: emit: ")";
             end else.
             end if.
        end else.
        end if.
    end method.

    has method emitIfStmt: stmt: void* -> void:
        ifRec: IfStmt <- stmt;
        self: emit: "if (({";
        self: indent;
        
        # Emit condition block statements as expression
        self: emitBlockAsExpression: ifRec.condition;
        
        self: dedent;
        self: emit: "}))"; 
        self: emitLine: " {";
        self: indent;
        self: emitBlock: ifRec.thenBranch;
        self: dedent;
        if:
        condition:
            return ifRec.elseBranch != nil;
        end condition.
        then:
             self: emitLine: "} else {";
             self: indent;
             self: emitBlock: ifRec.elseBranch;
             self: dedent;
        end then.
        end if.
        self: emitLine: "}";
    end method.

    has method emitWhileStmt: stmt: void* -> void:
        w: WhileStmt <- stmt;
        self: emit: "while (";
        self: emitExpression: w.condition;
        self: emit: ")";
        self: emitLine: " {";
        self: indent;
        self: emitBlock: w.body;
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitLoopStmt: stmt: void* -> void:
        l: LoopStmt <- stmt;
        self: emitLine: "while (true) {";
        self: indent;
        self: emitBlock: l.body;
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitScopedStmt: stmt: void* -> void:
        s: ScopedStmt <- stmt;
        self: emitLine: "{ /* scoped */";
        self: indent;
        self: emitBlock: s.body;
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitBlock: stmt: void* -> void:
        b: Block <- stmt;
        l: ASTList <- b.stmts;
        if:
        condition:
            return l != nil;
        end condition.
        then:
             n: ASTNode <- l.head;
             loop:
                 if:
                 condition:
                     return n == nil;
                 end condition.
                 then:
                     break;
                 end then.
                 end if.
                 self: emitStatement: n.value;
                 n <- n.next;
             end loop.
        end then.
        end if.
    end method.

    has method emitBlockAsExpression: blk: void* -> void:
        b: Block <- blk;
        let l: ASTList <- b.stmts;
        if:
        condition:
            return l == nil;
        end condition.
        then:
            return;
        end then.
        end if.
        
        let n: ASTNode <- l.head;
        loop:
            if:
            condition:
                return n == nil;
            end condition.
            then:
                break;
            end then.
            end if.
            let stmt: void* <- n.value;
            let h: Header <- stmt;
            
            if:
            condition:
                return h.type == "ReturnStmt";
            end condition.
            then:
                # Special handling for return in condition block
                let ret: ReturnStmt <- stmt;
                if:
                condition:
                    return ret.value != nil;
                end condition.
                then:
                    self: emitExpression: ret.value;
                    self: emitLine: ";";
                end then.
                end if.
            end then.
            else:
                self: emitStatement: stmt;
                end else.
            end if.
            
            n <- n.next;
        end loop.
    end method.

    has method emitModuleDecl: node: void* -> void:
        mod: ModuleDecl <- node;
        self: emitLine: "// Module: " + mod.name;
    end method.

    has method emitEntityDecl: node: void* -> void:
        ent: EntityDecl <- node;
        self: emitLine: "// Entity: " + ent.name;
        
        # Emit struct for entity fields
        self: emitLine: "struct " + ent.name + " {";
        self: indent;
        
        # Every entity has a 'type' field for simple RTTI if needed
        self: emitLine: "char* type;";
        
        if:
        condition:
            return ent.fields != nil;
        end condition.
        then:
            flist: ASTList <- ent.fields;
            fn: ASTNode <- flist.head;
            loop:
                if:
                condition:
                    return fn == nil;
                end condition.
                then:
                    break;
                end then.
                end if.
                field: FieldDecl <- fn.value;
                self: emitLine: (self: mapType: field.fieldType) + " " + field.name + ";";
                fn <- fn.next;
            end loop.
        end then.
        end if.
        self: dedent;
        self: emitLine: "};";
        
        oldEntity <- self.currentEntity;
        self.currentEntity <- ent.name;
        
        list: ASTList <- ent.methods;
        if:
        condition:
            return list != nil;
        end condition.
        then:
            n: ASTNode <- list.head;
            loop:
                if:
                condition:
                    return n == nil;
                end condition.
                then:
                    break;
                end then.
                end if.
                self: emitMethodDecl: n.value;
                n <- n.next;
            end loop.
        end then.
        end if.
        
        self.currentEntity <- oldEntity;
    end method.

    has method emitMethodDecl: node: void* -> void:
        meth: MethodDecl <- node;
        
        # Mangled Name
        mangledName <- self.currentEntity + "_" + meth.name;
        
        # Return Type
        retType <- self: mapType: meth.returnType;
        
        # Signature
        self: emit: retType + " " + mangledName + "(";
        
        # Parameters
        self: emit: "void* _self"; # Every method gets _self
        
        params: ASTList <- meth.params;
        if:
        condition:
            return params != nil;
        end condition.
        then:
            n: ASTNode <- params.head;
            loop:
                if:
                condition:
                    return n == nil;
                end condition.
                then:
                    break;
                end then.
                end if.
                p: FieldDecl <- n.value;
                self: emit: ", " + (self: mapType: p.fieldType) + " " + p.name;
                n <- n.next;
            end loop.
        end then.
        end if.
        
        self: emitLine: ") {";
        self: indent;
        
        # Cast _self to entity type
        self: emitLine: "struct " + self.currentEntity + "* self = (struct " + self.currentEntity + "*)_self;";
        
        # Body
        self: emitBlock: meth.body;
        
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitIncludeDecl: node: void* -> void:
        inc: IncludeDecl <- node;
        self: emitLine: "// Include: " + inc.path;
    end method.

    has method emitImportDecl: node: void* -> void:
        imp: ImportDecl <- node;
        self: emitLine: "// import " + imp.name;
    end method.

    has method emitUnabstractedBlock: node: void* -> void:
        un: UnabstractedBlock <- node;
        self: emitBlock: un.body;
    end method.

    has method emitAsmStmt: node: void* -> void:
        as: AsmStmt <- node;
        if:
        condition:
            return as.target == "c";
        end condition.
        then:
             self: emitLine: as.code;
        end then.
        end if.
    end method.

end Entity.
