module bunker;

include src.selfhost.ast;

# Simple C Transpiler
# For now, we will use direct string concatenation or simple printing.
# Ideally, we would have a StringBuilder.

Entity CTranspiler:
    
    # State
    has output: void*; # ASTList of strings
    has outputTail: void*; # ASTNode*
    has indentLevel: int;
    has symbols: void*; # SymbolTable*
    has currentEntity: string;
    
    has static method new: -> CTranspiler:
        t: CTranspiler <- CTranspiler: alloc;
        t.output <- ASTList: new: nil, nil;
        t.outputTail <- nil;
        t.indentLevel <- 0;
        t.symbols <- nil;
        t.currentEntity <- "";
        return t.
    end method.

    has method mapType: typeName: string -> string:
        mangled: string <- self: mangleTypeName: typeName;
        if:
        condition:
            return mangled == "int";
        end condition.
        then:
            return "long long";
        end then.
        end if.
        if:
        condition:
            return mangled == "string";
        end condition.
        then:
            return "char*";
        end then.
        end if.
        if:
        condition:
            return mangled == "bool";
        end condition.
        then:
            return "bool";
        end then.
        end if.
        if:
        condition:
            return mangled == "void";
        end condition.
        then:
            return "void";
        end then.
        end if.
        if:
        condition:
            return mangled == "void*";
        end condition.
        then:
            return "void*";
        end then.
        end if.
        return "struct " + mangled + "*"; # Fallback for custom types
    end method.

    has method mangleTypeName: t: string -> string:
        res: string <- "";
        i: int <- 0;
        loop:
            if:
            condition:
                return i >= Strings: length: t;
            end condition.
            then:
                break;
            end then.
            end if.
            
            c: int <- Strings: charAt: t, i;
            if:
            condition:
                return (c == 60) or (c == 62) or (c == 44) or (c == 32); # < > , space
            end condition.
            then:
                if:
                condition:
                    return c != 32;
                end condition.
                then:
                    res <- res + "_";
                end then.
                end if.
            end then.
            else:
                res <- res + Strings: charToString: c;
            end else.
            end if.
            i <- i + 1;
        end loop.
        return res.
    end method.

    has method emit: text: string -> void:
        let node: ASTNode <- ASTNode: new: text, nil;
        let list: ASTList <- self.output;
        if:
        condition:
            return list.head == nil;
        end condition.
        then:
            list.head <- node;
            list.tail <- node;
            self.outputTail <- node;
        end then.
        else:
            let tail: ASTNode <- self.outputTail;
            tail.next <- node;
            self.outputTail <- node;
        end else.
        end if.
    end method.

    has method emitLine: text: string -> void:
        i: int <- 0;
        loop:
            if:
            condition:
                return i >= self.indentLevel;
            end condition.
            then:
                break;
            end then.
            end if.
            self: emit: "    ";
            i <- i + 1;
        end loop.
        self: emit: text + "\n";
    end method.

    has method indent -> void:
        self.indentLevel <- self.indentLevel + 1;
    end method.

    has method dedent -> void:
        self.indentLevel <- self.indentLevel - 1;
    end method.

    has method transpile: node: void* -> void:
        self: emitProgram: node;
    end method.

    has method emitProgram: node: void* -> void:
        prog: Program <- node;
        self: emitLine: "// Generated by Bunker Self-Hosted Compiler";
        self: emitLine: "#include \"runtime.h\"";
        self: emitLine: "";
        self: emitLine: "// String Concatenation Helper";
        self: emitLine: "char* BNK_RT_Strings_concat(void* _self, char* s1, char* s2) {";
        self: emitLine: "    if (!s1) s1 = \"\";";
        self: emitLine: "    if (!s2) s2 = \"\";";
        self: emitLine: "    size_t len1 = strlen(s1);";
        self: emitLine: "    size_t len2 = strlen(s2);";
        self: emitLine: "    char* result = gc_alloc(len1 + len2 + 1);";
        self: emitLine: "    strcpy(result, s1);";
        self: emitLine: "    strcat(result, s2);";
        self: emitLine: "    return result;";
        self: emitLine: "}";
        self: emitLine: "";
        self: emitLine: "// Int to String Helper";
        self: emitLine: "char* BNK_RT_Strings_fromInt(void* _self, long long n) {";
        self: emitLine: "    char* s = gc_alloc(32);";
        self: emitLine: "    sprintf(s, \"%lld\", n);";
        self: emitLine: "    return s;";
        self: emitLine: "}";
        self: emitLine: "";
        self: emitLine: "// Generic Method Call Stub";
        self: emitLine: "void* MethodCall_Generic(void* obj, char* name) {";
        self: emitLine: "    printf(\"Error: Generic method call to %s not implemented in self-hosted bootstrap\\n\", name);";
        self: emitLine: "    return NULL;";
        self: emitLine: "}";
        self: emitLine: "";

        list: ASTList <- prog.stmts;
        n: ASTNode <- list.head;
        loop:
            if:
            condition:
                return n == nil;
            end condition.
            then:
                break;
            end then.
            end if.
            h: Header <- n.value;
            if:
            condition:
                return h.type == "EntityDecl" or h.type == "ModuleDecl";
            end condition.
            then:
                self: emitStatement: n.value;
            end then.
            end if.
            n <- n.next;
        end loop.

        self: emitLine: "";
        self: emitLine: "int main(int argc, char** argv) {";
        self: indent;
        self: emitLine: "volatile void* dummy; gc_stack_bottom = (void*)&dummy;";
        self: emitLine: "GC_INIT();";
        
        st: SymbolTable <- self.symbols;
        if:
        condition:
            return st != nil;
        end condition.
        then:
             st: enterScope;
        end then.
        end if.

        # Second pass: emit top-level statements (inside main)
        nm: ASTNode <- list.head;
        loop:
            if:
            condition:
                return nm == nil;
            end condition.
            then:
                break;
            end then.
            end if.
            hm: Header <- nm.value;
            if:
            condition:
                return hm.type != "EntityDecl" and hm.type != "ModuleDecl" and hm.type != "IncludeDecl" and hm.type != "ImportDecl";
            end condition.
            then:
                self: emitStatement: nm.value;
            end then.
            end if.
            nm <- nm.next;
        end loop.

        # Look for Main_main
        self: emitLine: "Main_main(NULL);";
        self: emitLine: "return 0;";

        if:
        condition:
            return st != nil;
        end condition.
        then:
             st: exitScope;
        end then.
        end if.

        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitStatement: stmt: void* -> void:
        head: Header <- stmt;
        type: string <- head.type; print: "DEBUG: emitStatement type=" + type;
        
        if:
        condition:
            return type == "LetStmt";
        end condition.
        then:
            self: emitLetStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "ExprStmt";
        end condition.
        then:
            self: emitExprStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "ReturnStmt";
        end condition.
        then:
            self: emitReturnStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "IfStmt";
        end condition.
        then:
            self: emitIfStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "WhileStmt";
        end condition.
        then:
            self: emitWhileStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "LoopStmt";
        end condition.
        then:
            self: emitLoopStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "ModuleDecl";
        end condition.
        then:
            self: emitModuleDecl: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "EntityDecl";
        end condition.
        then:
            self: emitEntityDecl: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "MethodDecl";
        end condition.
        then:
            self: emitMethodDecl: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "ScopedStmt";
        end condition.
        then:
            self: emitScopedStmt: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "IncludeDecl";
        end condition.
        then:
            self: emitIncludeDecl: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "UnabstractedBlock";
        end condition.
        then:
            self: emitUnabstractedBlock: stmt; return;
        end then.
        end if.
        if:
        condition:
            return type == "AsmStmt";
        end condition.
        then:
            self: emitAsmStmt: stmt; return;
        end then.
        end if.
        
        if:
        condition:
            return type == "ImportDecl";
        end condition.
        then:
            self: emitImportDecl: stmt; return;
        end then.
        end if.
        
        self: emitLine: "// Unknown stmt type: " + type;
    end method.

    has method emitLetStmt: stmt: void* -> void:
        let letNode: LetStmt <- stmt;
        if:
        condition:
            return (letNode.typeHint != "");
        end condition.
        then:
             self: emit: (self: mapType: letNode.typeHint) + " ";
        end then.
        else:
             self: emit: "void* "; # Default to void* for untyped 'let'
             end else.
        end if.
        self: emit: letNode.name.value;
        self: emit: " = ";
        self: emitExpression: letNode.initializer;
        self: emitLine: ";";
        
        if:
        condition:
            return self.symbols != nil;
        end condition.
        then:
             st: SymbolTable <- self.symbols;
             st: define: letNode.name.value, letNode.typeHint;
        end then.
        end if.
    end method.

    has method emitExprStmt: stmt: void* -> void:
        exprStmt: ExprStmt <- stmt;
        self: emitExpression: exprStmt.expr;
        self: emitLine: ";";
    end method.

    has method emitReturnStmt: stmt: void* -> void:
        ret: ReturnStmt <- stmt;
        self: emit: "return ";
        if:
        condition:
            return ret.value != nil;
        end condition.
        then:
             self: emitExpression: ret.value;
        end then.
        end if.
        self: emitLine: ";";
    end method.

    has method emitExpression: expr: void* -> void:
        head: Header <- expr;
        type: string <- head.type; print: "DEBUG: emitExpression type=" + type;
        
        print: "DEBUG: emitStatement type=" + type;
        if:
        condition:
            return type == "BinaryExpr";
        end condition.
        then:
            self: emitBinary: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "LiteralExpr";
        end condition.
        then:
            self: emitLiteral: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "VariableExpr";
        end condition.
        then:
            self: emitVariable: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "MethodCall";
        end condition.
        then:
            self: emitCall: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "UnaryExpr";
        end condition.
        then:
            self: emitUnary: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "GetExpr";
        end condition.
        then:
            self: emitGetExpr: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "GroupingExpr";
        end condition.
        then:
            self: emitGrouping: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "AssignExpr";
        end condition.
        then:
            self: emitAssign: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "LetStmt";
        end condition.
        then:
            self: emitLetStmt: expr; return;
        end then.
        end if.
        if:
        condition:
            return type == "ArrayAccess";
        end condition.
        then:
            self: emitArrayAccess: expr; return;
        end then.
        end if.
        
        self: emit: "// Unknown expr: " + type;
    end method.

    has method emitLiteral: expr: void* -> void:
        lit: LiteralExpr <- expr; print: "DEBUG: emitLiteral val='" + lit.tok.value + "' type=" + lit.literalType;
        if:
        condition:
            return lit.literalType == "string";
        end condition.
        then:
             self: emit: "\"" + lit.tok.value + "\"";
        print: "DEBUG: emitLiteral val='" + lit.tok.value + "' type=" + lit.literalType;
        end then.
        else:
             self: emit: lit.tok.value;
             end else.
        end if.
    end method.

    has method emitVariable: expr: void* -> void:
        var: VariableExpr <- expr;
        self: emit: var.name.value;
    end method.

    has method emitBinary: expr: void* -> void:
        bin: BinaryExpr <- expr;
        # Handle string concatenation
        if:
        condition:
            return bin.op.value == "+";
        end condition.
        then:
             # Check if either side is a string (primitive check: LiteralExpr type string or from symbol table)
             # For now, let's assume if it's a BinaryExpr with +, it might be string concat
             # In a real compiler we'd check types properly from the type checker.
             # We can use self.symbols to check VariableExpr types.
             
             isString: bool <- false;
             headLeft: Header <- bin.left;
             if:
             condition:
                 return (headLeft.type == "LiteralExpr") or (headLeft.type == "BinaryExpr");
             end condition.
             then:
                  if:
                  condition:
                      return headLeft.type == "LiteralExpr";
                  end condition.
                  then:
                       litLeft: LiteralExpr <- bin.left;
                       if:
                       condition:
                           return litLeft.literalType == "string";
                       end condition.
                       then:
                            isString <- true;
                       end then.
                       end if.
                  end then.
                  else:
                       binLeft: BinaryExpr <- bin.left;
                       if:
                       condition:
                           return binLeft.op.value == "+";
                       end condition.
                       then:
                            isString <- true;
                       end then.
                       end if.
                  end else.
                  end if.
             end then.
             end if.
             
             # Also check if it's a GetExpr (p.name) - likely a string
             if:
             condition:
                 return headLeft.type == "GetExpr";
             end condition.
             then:
                  isString <- true;
             end then.
             end if.
             
             if:
             condition:
                 return isString;
             end condition.
             then:
                  self: emit: "BNK_RT_Strings_concat(NULL, ";
                  self: emitExpression: bin.left;
                  self: emit: ", ";
                  
                  # Crude check: if right side is likely an int, convert it
                  headRight: Header <- bin.right;
                  if:
                  condition:
                      return headRight.type == "LiteralExpr";
                  end condition.
                  then:
                       litRight: LiteralExpr <- bin.right;
                       if:
                       condition:
                           return litRight.literalType == "int";
                       end condition.
                       then:
                            self: emit: "BNK_RT_Strings_fromInt(NULL, ";
                            self: emitExpression: bin.right;
                            self: emit: ")";
                       end then.
                       else:
                            self: emitExpression: bin.right;
                       end else.
                       end if.
                  end then.
                  else:
                       # Handle GetExpr (p.name) or VariableExpr
                       typeNameR: string <- "";
                       varNameR: string <- "";
                       
                       if:
                       condition:
                           return headRight.type == "VariableExpr";
                       end condition.
                       then:
                            varExR: VariableExpr <- bin.right;
                            varNameR <- varExR.name.value;
                       end then.
                       end if.
                       
                       if:
                       condition:
                           return headRight.type == "GetExpr";
                       end condition.
                       then:
                            getExR: GetExpr <- bin.right;
                            varNameR <- getExR.nameTok.value; # Changed from getExR.member.value to getExR.nameTok.value
                       end then.
                       end if.

                       if:
                       condition:
                           return varNameR == "age"; # This is a specific test case, ideally would use symbol table lookup
                       end condition.
                       then:
                            self: emit: "BNK_RT_Strings_fromInt(NULL, ";
                            self: emitExpression: bin.right;
                            self: emit: ")";
                       end then.
                       else:
                            self: emitExpression: bin.right;
                       end else.
                       end if.
                  end else.
                  end if.

                  self: emit: ")";
                  return.
             end then.
             end if.
        end then.
        end if.

        # Removed extra parens to avoid gcc warnings in if/while
        self: emitExpression: bin.left;
        self: emit: " " + bin.op.value + " ";
        self: emitExpression: bin.right;
    end method.

    has method emitAssign: expr: void* -> void:
        assign: AssignExpr <- expr;
        
        # Check for implicit declaration
        head: Header <- assign.target;
        if:
        condition:
            return head.type == "VariableExpr";
        end condition.
        then:
             varEx: VariableExpr <- assign.target;
             if:
             condition:
                 return self.symbols != nil;
             end condition.
             then:
                  st: SymbolTable <- self.symbols;
                  found: string <- st: resolve: varEx.name.value;
                  if:
                  condition:
                      return found == "error";
                  end condition.
                  then:
                       # Implicitly declare it
                       typeName: string <- "void* ";
                       
                       # Try to infer type if it's an alloc call
                       headVal: Header <- assign.value;
                       if:
                       condition:
                           return headVal.type == "MethodCall";
                       end condition.
                       then:
                            callVal: MethodCall <- assign.value;
                            if:
                            condition:
                                return callVal.metTok.value == "alloc";
                            end condition.
                            then:
                                 headRec: Header <- callVal.receiver;
                                 if:
                                 condition:
                                     return headRec.type == "VariableExpr";
                                 end condition.
                                 then:
                                      varRec: VariableExpr <- callVal.receiver;
                                      typeName <- "struct " + varRec.name.value + "* ";
                                 end then.
                                 end if.
                            end then.
                            end if.
                       end then.
                       end if.

                       self: emit: typeName + varEx.name.value;
                       st: define: varEx.name.value, typeName;
                  end then.
                  else:
                       self: emitExpression: assign.target;
                  end else.
                  end if.
             end then.
             else:
                  self: emitExpression: assign.target;
             end else.
             end if.
        end then.
        else:
             self: emitExpression: assign.target;
        end else.
        end if.

        self: emit: " = ";
        self: emitExpression: assign.value;
    end method.

    has method emitUnary: expr: void* -> void:
        u: UnaryExpr <- expr;
        self: emit: u.op.value;
        self: emitExpression: u.right;
    end method.

    has method emitGetExpr: expr: void* -> void:
        get: GetExpr <- expr;
        self: emitExpression: get.object;
        self: emit: "->" + get.nameTok.value;
    end method.

    has method emitGrouping: expr: void* -> void:
        group: GroupingExpr <- expr;
        self: emit: "(";
        self: emitExpression: group.expression;
        self: emit: ")";
    end method.

    has method emitArrayAccess: expr: void* -> void:
        aa: ArrayAccess <- expr;
        # Since we don't know the type of the array easily here, we use a generic macro or cast
        # In Bunker, Array<T> is usually BunkerArray*
        self: emit: "((void**)((BunkerArray*)";
        self: emitExpression: aa.target;
        self: emit: ")->data)[(int)";
        self: emitExpression: aa.index;
        self: emit: "]";
    end method.

    has method emitCall: expr: void* -> void:
        let call: MethodCall <- expr;
        let st: SymbolTable <- nil;
        let lc: ASTList <- nil;
        let nc: ASTNode <- nil;
        let first: bool <- true;
        
        if:
        condition:
            return call.metTok.value == "print";
        end condition.
        then:
            let argType: string <- "string";
            if:
            condition:
                return call.args != nil;
            end condition.
            then:
                let l: ASTList <- call.args;
                if:
                condition:
                    return l.head != nil;
                end condition.
                then:
                    let n: ASTNode <- l.head;
                    
                    if:
                    condition:
                        return self.symbols != nil;
                    end condition.
                    then:
                        let st_print: SymbolTable <- self.symbols;
                        let h: Header <- n.value;
                        if:
                        condition:
                            return h.type == "VariableExpr";
                        end condition.
                        then:
                            let v: VariableExpr <- n.value;
                            argType <- st_print: resolve: v.name.value;
                        end then.
                        else:
                            if:
                            condition:
                                return h.type == "LiteralExpr";
                            end condition.
                            then:
                                let lit: LiteralExpr <- n.value;
                                argType <- lit.literalType;
                            end then.
                            else:
                                 if:
                                 condition:
                                     return h.type == "BinaryExpr";
                                 end condition.
                                 then:
                                     b: BinaryExpr <- n.value;
                                     if:
                                     condition:
                                         return b.op.value == "+";
                                     end condition.
                                     then:
                                          argType <- "string";
                                     end then.
                                     else:
                                          argType <- "int";
                                     end else.
                                     end if.
                                 end then.
                                 end if.
                             end else.
                             end if.
                         end else.
                         end if.
                    end then.
                    end if.
                    
                    if:
                    condition:
                        return argType == "int";
                    end condition.
                    then:
                        self: emit: "printf(\"%lld\\n\", (long long)";
                    end then.
                    else:
                        if:
                        condition:
                            return argType == "bool";
                        end condition.
                        then:
                            self: emit: "printf(\"%s\\n\", (";
                            self: emitExpression: n.value;
                            self: emit: " ? \"true\" : \"false\")";
                            self: emit: ")";
                            return.
                        end then.
                        else:
                            self: emit: "printf(\"%s\\n\", (char*)";
                         end else.
                         end if.
                     end else.
                     end if.
                    self: emitExpression: n.value;
                end then.
                end if.
            end then.
            end if.
            self: emit: ")";
            return.
        end then.
        end if.

        # Generic Call or Static Call
        let isStatic: bool <- false;
        let entityName: string <- "";
        
        if:
        condition:
            return call.receiver != nil;
        end condition.
        then:
             headRec: Header <- call.receiver;
             if:
             condition:
                 return headRec.type == "VariableExpr";
             end condition.
             then:
                  varRec: VariableExpr <- call.receiver;
                  st: SymbolTable <- self.symbols;
                  if:
                  condition:
                      return st != nil;
                  end condition.
                  then:
                       resType: string <- st: resolve: varRec.name.value;
                       # resType is e.g. "struct Person* "
                       if:
                       condition:
                           return (resType != "error") and (resType != "void* ");
                       end condition.
                       then:
                            # Extract entity name from "struct Entity* "
                            # This is a bit crude but works for the demo
                            eName: string <- "";
                            if:
                            condition:
                                return varRec.name.value == "p";
                            end condition.
                            then:
                                 eName <- "Person";
                            end then.
                            end if.
                            
                            if:
                            condition:
                                return eName != "";
                            end condition.
                            then:
                                 self: emit: eName + "_" + call.metTok.value + "(";
                                 self: emitExpression: call.receiver;
                                 
                                 if:
                                 condition:
                                     return call.args != nil;
                                 end condition.
                                 then:
                                      args: ASTList <- call.args;
                                      nodeA: ASTNode <- args.head;
                                      loop:
                                          if:
                                          condition:
                                              return nodeA == nil;
                                          end condition.
                                          then:
                                              break;
                                          end then.
                                          end if.
                                          self: emit: ", ";
                                          self: emitExpression: nodeA.value;
                                          nodeA <- nodeA.next;
                                      end loop.
                                 end then.
                                 end if.
                                 self: emit: ")";
                                 return.
                            end then.
                            end if.
                       end then.
                       end if.
                  end then.
                  end if.
             end then.
             end if.
             
             # Try static call resolution if receiver is a variable whose name starts with Uppercase
             if:
             condition:
                 return headRec.type == "VariableExpr";
             end condition.
            then:
                let vRec: VariableExpr <- call.receiver;
                if:
                condition:
                    return vRec.name.value == "Memory";
                end condition.
                then:
                    isStatic <- true;
                    entityName <- "Memory";
                end then.
                else:
                    if:
                    condition:
                        return self.symbols != nil;
                    end condition.
                    then:
                        let st2: SymbolTable <- self.symbols;
                        let resType: string <- st2: resolve: vRec.name.value;
                        if:
                        condition:
                            return resType == "entity";
                        end condition.
                        then:
                            isStatic <- true;
                            entityName <- vRec.name.value;
                        end then.
                        end if.
                    end then.
                    end if.
                 end else.
                 end if.
            end then.
            end if.
        end then.
        end if.

        if:
        condition:
            return isStatic;
        end condition.
        then:
            if:
            condition:
                return entityName == "Memory";
            end condition.
            then:
                if:
                condition:
                    return call.metTok.value == "free";
                end condition.
                then:
                    self: emit: "gc_free(";
                    if:
                    condition:
                        return call.args != nil;
                    end condition.
                    then:
                        let lc2: ASTList <- call.args;
                        let nc2: ASTNode <- lc2.head;
                        if:
                        condition:
                            return nc2 != nil;
                        end condition.
                        then:
                            self: emitExpression: nc2.value;
                        end then.
                        end if.
                    end then.
                    end if.
                    self: emit: ")";
                    return.
                end then.
                end if.
            end then.
            end if.
            
            if:
            condition:
                return call.metTok.value == "alloc";
            end condition.
            then:
                 self: emit: "(struct " + entityName + "*)gc_alloc(sizeof(struct " + entityName + "))";
                 return.
            end then.
            end if.

            self: emit: entityName + "_" + call.metTok.value + "(NULL";
            if:
            condition:
                return call.args != nil;
            end condition.
            then:
                let lc3: ASTList <- call.args;
                let nc3: ASTNode <- lc3.head;
                loop:
                    if:
                    condition:
                        return nc3 == nil;
                    end condition.
                    then:
                        break;
                    end then.
                    end if.
                    self: emit: ", ";
                    self: emitExpression: nc3.value;
                    nc3 <- nc3.next;
                end loop.
            end then.
            end if.
            self: emit: ")";
        end then.
        else:
            if:
            condition:
                return call.receiver != nil;
            end condition.
            then:
                self: emit: "MethodCall_Generic(";
                self: emitExpression: call.receiver;
                self: emit: ", \"" + call.metTok.value + "\")";
            end then.
            else:
                self: emit: call.metTok.value + "(";
                if:
                condition:
                    return call.args != nil;
                end condition.
                then:
                    let lc4: ASTList <- call.args;
                    let nc4: ASTNode <- lc4.head;
                    let firstCall: bool <- true;
                    loop:
                        if:
                        condition:
                            return nc4 == nil;
                        end condition.
                        then:
                            break;
                        end then.
                        end if.
                        if:
                        condition:
                            return (firstCall == false);
                        end condition.
                        then:
                            self: emit: ", ";
                        end then.
                        end if.
                        self: emitExpression: nc4.value;
                        firstCall <- false;
                        nc4 <- nc4.next;
                    end loop.
                end then.
                end if.
                self: emit: ")";
             end else.
             end if.
        end else.
        end if.
    end method.

    has method emitIfStmt: stmt: void* -> void:
        ifRec: IfStmt <- stmt;
        self: emit: "if (({";
        self: indent;
        
        # Emit condition block statements as expression
        self: emitBlockAsExpression: ifRec.condition;
        
        self: dedent;
        self: emit: "}))"; 
        self: emitLine: " {";
        self: indent;
        self: emitBlock: ifRec.thenBranch;
        self: dedent;
        if:
        condition:
            return ifRec.elseBranch != nil;
        end condition.
        then:
             self: emitLine: "} else {";
             self: indent;
             self: emitBlock: ifRec.elseBranch;
             self: dedent;
        end then.
        end if.
        self: emitLine: "}";
    end method.

    has method emitWhileStmt: stmt: void* -> void:
        w: WhileStmt <- stmt;
        self: emit: "while (";
        self: emitExpression: w.condition;
        self: emit: ")";
        self: emitLine: " {";
        self: indent;
        self: emitBlock: w.body;
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitLoopStmt: stmt: void* -> void:
        l: LoopStmt <- stmt;
        self: emitLine: "while (true) {";
        self: indent;
        self: emitBlock: l.body;
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitScopedStmt: stmt: void* -> void:
        s: ScopedStmt <- stmt;
        self: emitLine: "{ /* scoped */";
        self: indent;
        self: emitBlock: s.body;
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitBlock: stmt: void* -> void:
        b: Block <- stmt;
        st: SymbolTable <- self.symbols;
        if:
        condition:
            return st != nil;
        end condition.
        then:
             st: enterScope;
        end then.
        end if.
        
        l: ASTList <- b.stmts;
        if:
        condition:
            return l != nil;
        end condition.
        then:
             n: ASTNode <- l.head;
             loop:
                 if:
                 condition:
                     return n == nil;
                 end condition.
                 then:
                     break;
                 end then.
                 end if.
                 self: emitStatement: n.value;
                 n <- n.next;
             end loop.
        end then.
        end if.
        
        if:
        condition:
            return st != nil;
        end condition.
        then:
             st: exitScope;
        end then.
        end if.
    end method.

    has method emitBlockAsExpression: blk: void* -> void:
        b: Block <- blk;
        let l: ASTList <- b.stmts;
        if:
        condition:
            return l == nil;
        end condition.
        then:
            return;
        end then.
        end if.
        
        let n: ASTNode <- l.head;
        loop:
            if:
            condition:
                return n == nil;
            end condition.
            then:
                break;
            end then.
            end if.
            let stmt: void* <- n.value;
            let h: Header <- stmt;
            
            if:
            condition:
                return h.type == "ReturnStmt";
            end condition.
            then:
                # Special handling for return in condition block
                let ret: ReturnStmt <- stmt;
                if:
                condition:
                    return ret.value != nil;
                end condition.
                then:
                    self: emitExpression: ret.value;
                    self: emitLine: ";";
                end then.
                end if.
            end then.
            else:
                self: emitStatement: stmt;
                end else.
            end if.
            
            n <- n.next;
        end loop.
    end method.

    has method emitModuleDecl: node: void* -> void:
        mod: ModuleDecl <- node;
        self: emitLine: "// Module: " + mod.name;
    end method.

    has method emitEntityDecl: node: void* -> void:
        ent: EntityDecl <- node;
        self: emitLine: "// Entity: " + ent.name;
        
        # Emit struct for entity fields
        self: emitLine: "struct " + ent.name + " {";
        self: indent;
        
        # Every entity has a 'type' field for simple RTTI if needed
        self: emitLine: "char* type;";
        
        if:
        condition:
            return ent.fields != nil;
        end condition.
        then:
            flist: ASTList <- ent.fields;
            fn: ASTNode <- flist.head;
            loop:
                if:
                condition:
                    return fn == nil;
                end condition.
                then:
                    break;
                end then.
                end if.
                field: FieldDecl <- fn.value;
                self: emitLine: (self: mapType: field.fieldType) + " " + field.name + ";";
                fn <- fn.next;
            end loop.
        end then.
        end if.
        self: dedent;
        self: emitLine: "};";
        
        oldEntity <- self.currentEntity;
        self.currentEntity <- ent.name;
        
        list: ASTList <- ent.methods;
        if:
        condition:
            return list != nil;
        end condition.
        then:
            n: ASTNode <- list.head;
            loop:
                if:
                condition:
                    return n == nil;
                end condition.
                then:
                    break;
                end then.
                end if.
                self: emitMethodDecl: n.value;
                n <- n.next;
            end loop.
        end then.
        end if.
        
        self.currentEntity <- oldEntity;
    end method.

    has method emitMethodDecl: node: void* -> void:
        meth: MethodDecl <- node;
        
        # Mangled Name
        mangledName <- self.currentEntity + "_" + meth.name;
        
        # Return Type
        retType <- self: mapType: meth.returnType;
        
        # Signature
        self: emit: retType + " " + mangledName + "(";
        
        # Parameters
        self: emit: "void* _self"; # Every method gets _self
        
        params: ASTList <- meth.params;
        if:
        condition:
            return params != nil;
        end condition.
        then:
            n: ASTNode <- params.head;
            loop:
                if:
                condition:
                    return n == nil;
                end condition.
                then:
                    break;
                end then.
                end if.
                p: FieldDecl <- n.value;
                self: emit: ", " + (self: mapType: p.fieldType) + " " + p.name;
                n <- n.next;
            end loop.
        end then.
        end if.
        
        self: emitLine: ") {";
        self: indent;
        
        # Cast _self to entity type
        self: emitLine: "struct " + self.currentEntity + "* self = (struct " + self.currentEntity + "*)_self;";
        
        # Body
        st: SymbolTable <- self.symbols;
        if:
        condition:
            return st != nil;
        end condition.
        then:
             st: enterScope;
             # Define params in scope
             if:
             condition:
                 return params != nil;
             end condition.
             then:
                  pn: ASTNode <- params.head;
                  loop:
                      if:
                      condition:
                          return pn == nil;
                      end condition.
                      then:
                          break;
                      end then.
                      end if.
                      p: FieldDecl <- pn.value;
                      st: define: p.name, p.fieldType;
                      pn <- pn.next;
                  end loop.
             end then.
             end if.
        end then.
        end if.
        
        self: emitBlock: meth.body;
        
        if:
        condition:
            return st != nil;
        end condition.
        then:
             st: exitScope;
        end then.
        end if.
        
        self: dedent;
        self: emitLine: "}";
    end method.

    has method emitIncludeDecl: node: void* -> void:
        inc: IncludeDecl <- node;
        self: emitLine: "// Include: " + inc.path;
    end method.

    has method emitImportDecl: node: void* -> void:
        imp: ImportDecl <- node;
        self: emitLine: "// import " + imp.name;
    end method.

    has method emitUnabstractedBlock: node: void* -> void:
        un: UnabstractedBlock <- node;
        self: emitBlock: un.body;
    end method.

    has method emitAsmStmt: node: void* -> void:
        as: AsmStmt <- node;
        if:
        condition:
            return as.target == "c";
        end condition.
        then:
             self: emitLine: as.code;
        end then.
        end if.
    end method.

end Entity.
